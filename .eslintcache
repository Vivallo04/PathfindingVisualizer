[{"D:\\Development\\WebstormProjects\\pathfinding\\src\\index.js":"1","D:\\Development\\WebstormProjects\\pathfinding\\src\\App.js":"2","D:\\Development\\WebstormProjects\\pathfinding\\src\\PathfindginVisualizer\\PathfindingVisualizer.js":"3","D:\\Development\\WebstormProjects\\pathfinding\\src\\algorithms\\dijkstraAlgorithm.js":"4","D:\\Development\\WebstormProjects\\pathfinding\\src\\PathfindginVisualizer\\Node\\Node.js":"5"},{"size":169,"mtime":1612130087214,"results":"6","hashOfConfig":"7"},{"size":311,"mtime":1612130052467,"results":"8","hashOfConfig":"7"},{"size":5098,"mtime":1612133871051,"results":"9","hashOfConfig":"7"},{"size":2281,"mtime":1612131012484,"results":"10","hashOfConfig":"7"},{"size":1684,"mtime":1612133751887,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1tuhai9",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"19","messages":"20","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"14"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"D:\\Development\\WebstormProjects\\pathfinding\\src\\index.js",[],["24","25"],"D:\\Development\\WebstormProjects\\pathfinding\\src\\App.js",[],"D:\\Development\\WebstormProjects\\pathfinding\\src\\PathfindginVisualizer\\PathfindingVisualizer.js",[],"D:\\Development\\WebstormProjects\\pathfinding\\src\\algorithms\\dijkstraAlgorithm.js",["26"],"/*\r\n\r\n\r\n\r\n\r\n\r\n */\r\n\r\nexport function dijkstraAlgorithm(grid, startNode, endNode) {\r\n\r\n    const  visitedNodes = [];\r\n    startNode.distance = 0;\r\n\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while (!!unvisitedNodes.length) {\r\n\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n\r\n        //If we find a wall -> Skip\r\n        if (closestNode.isWall) continue;\r\n\r\n        //If the closest node is at distance of infinity,\r\n        //then we know we are trapped -> Stop\r\n        if (closestNode.distance === Infinity) {\r\n            return visitedNodes;\r\n        }\r\n        closestNode.isVisited = true;\r\n        visitedNodes.push(closestNode);\r\n\r\n        if (closestNode === endNode) {\r\n            return visitedNodes;\r\n        }\r\n        getUnvisitedNeighbors(closestNode, grid);\r\n\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(univisitedNodes) {\r\n\r\n    univisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n\r\nfunction updateVisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = neighbor.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n\r\n    if (row > 0) {\r\n        neighbors.push(grid[row - 1][col]);\r\n    }\r\n    if(row < grid.length - 1) {\r\n        neighbors.push(grid[row][col - 1]);\r\n    }\r\n    if(col > 0) {\r\n        neighbors.push(grid[row][col - 1]);\r\n    }\r\n    if(col < grid[0].length - 1) {\r\n        neighbors.push(grid[row][col + 1]);\r\n    }\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n\r\nfunction getAllNodes(grid) {\r\n\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let current = finishNode;\r\n\r\n    while (current !== null) {\r\n        nodesInShortestPathOrder.unshift(current);\r\n        current = current.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","D:\\Development\\WebstormProjects\\pathfinding\\src\\PathfindginVisualizer\\Node\\Node.js",[],{"ruleId":"27","replacedBy":"28"},{"ruleId":"29","replacedBy":"30"},{"ruleId":"31","severity":1,"message":"32","line":46,"column":10,"nodeType":"33","messageId":"34","endLine":46,"endColumn":32},"no-native-reassign",["35"],"no-negated-in-lhs",["36"],"no-unused-vars","'updateVisitedNeighbors' is defined but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]